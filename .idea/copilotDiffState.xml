<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/app/globals.css">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/globals.css" />
              <option name="originalContent" value="@import &quot;tailwindcss&quot;;&#10;@import &quot;tw-animate-css&quot;;&#10;&#10;@plugin &quot;tailwindcss-motion&quot;;&#10;&#10;@custom-variant dark (&amp;:is(.dark *));&#10;&#10;@theme inline {&#10;    --color-background: var(--background);&#10;    --color-foreground: var(--foreground);&#10;    --color-sidebar-ring: var(--sidebar-ring);&#10;    --color-sidebar-border: var(--sidebar-border);&#10;    --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);&#10;    --color-sidebar-accent: var(--sidebar-accent);&#10;    --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);&#10;    --color-sidebar-primary: var(--sidebar-primary);&#10;    --color-sidebar-foreground: var(--sidebar-foreground);&#10;    --color-ring: var(--ring);&#10;    --color-input: var(--input);&#10;    --color-border: var(--border);&#10;    --color-destructive: var(--destructive);&#10;    --color-accent-foreground: var(--accent-foreground);&#10;    --color-accent: var(--accent);&#10;    --color-muted-foreground: var(--muted-foreground);&#10;    --color-muted: var(--muted);&#10;    --color-secondary-foreground: var(--secondary-foreground);&#10;    --color-secondary: var(--secondary);&#10;    --color-primary-foreground: var(--primary-foreground);&#10;    --color-primary: var(--primary);&#10;    --color-popover-foreground: var(--popover-foreground);&#10;    --color-popover: var(--popover);&#10;    --color-card-foreground: var(--card-foreground);&#10;    --color-card: var(--card);&#10;    --radius-sm: calc(var(--radius) - 4px);&#10;    --radius-md: calc(var(--radius) - 2px);&#10;    --radius-lg: var(--radius);&#10;    --radius-xl: calc(var(--radius) + 4px);&#10;&#10;    --color-gallery-bg: hsl(var(--gallery-bg));&#10;    --color-gallery-text: hsl(var(--gallery-text));&#10;    --color-gallery-muted: hsl(var(--gallery-muted));&#10;    --color-glass-bg: hsl(var(--glass-bg));&#10;    --color-glass-border: hsl(var(--glass-border));&#10;    --color-button-glass: hsl(var(--button-glass));&#10;    --color-button-glass-hover: hsl(var(--button-glass-hover));&#10;}&#10;&#10;" />
              <option name="updatedContent" value="@import &quot;tailwindcss&quot;;&#10;@import &quot;tw-animate-css&quot;;&#10;&#10;@plugin &quot;tailwindcss-motion&quot;;&#10;&#10;@custom-variant dark (&amp;:is(.dark *));&#10;&#10;@theme inline {&#10;    --color-background: var(--background);&#10;    --color-foreground: var(--foreground);&#10;    --color-sidebar-ring: var(--sidebar-ring);&#10;    --color-sidebar-border: var(--sidebar-border);&#10;    --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);&#10;    --color-sidebar-accent: var(--sidebar-accent);&#10;    --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);&#10;    --color-sidebar-primary: var(--sidebar-primary);&#10;    --color-sidebar-foreground: var(--sidebar-foreground);&#10;    --color-ring: var(--ring);&#10;    --color-input: var(--input);&#10;    --color-border: var(--border);&#10;    --color-destructive: var(--destructive);&#10;    --color-accent-foreground: var(--accent-foreground);&#10;    --color-accent: var(--accent);&#10;    --color-muted-foreground: var(--muted-foreground);&#10;    --color-muted: var(--muted);&#10;    --color-secondary-foreground: var(--secondary-foreground);&#10;    --color-secondary: var(--secondary);&#10;    --color-primary-foreground: var(--primary-foreground);&#10;    --color-primary: var(--primary);&#10;    --color-popover-foreground: var(--popover-foreground);&#10;    --color-popover: var(--popover);&#10;    --color-card-foreground: var(--card-foreground);&#10;    --color-card: var(--card);&#10;    --radius-sm: calc(var(--radius) - 4px);&#10;    --radius-md: calc(var(--radius) - 2px);&#10;    --radius-lg: var(--radius);&#10;    --radius-xl: calc(var(--radius) + 4px);&#10;&#10;    --color-gallery-bg: hsl(var(--gallery-bg));&#10;    --color-gallery-text: hsl(var(--gallery-text));&#10;    --color-gallery-muted: hsl(var(--gallery-muted));&#10;    --color-glass-bg: hsl(var(--glass-bg));&#10;    --color-glass-border: hsl(var(--glass-border));&#10;    --color-button-glass: hsl(var(--button-glass));&#10;    --color-button-glass-hover: hsl(var(--button-glass-hover));&#10;}&#10;&#10;/* Hide scrollbars for carousel */&#10;.scrollbar-hide {&#10;  -ms-overflow-style: none;  /* Internet Explorer 10+ */&#10;  scrollbar-width: none;  /* Firefox */&#10;}&#10;&#10;.scrollbar-hide::-webkit-scrollbar { &#10;  display: none;  /* Safari and Chrome */&#10;}&#10;&#10;/* Smooth scroll behavior for carousel */&#10;.snap-x {&#10;  scroll-snap-type: x mandatory;&#10;}&#10;&#10;.snap-center {&#10;  scroll-snap-align: center;&#10;}&#10;&#10;.snap-mandatory {&#10;  scroll-snap-type: x mandatory;&#10;}&#10;&#10;/* Ensure smooth scrolling */&#10;html {&#10;  scroll-behavior: smooth;&#10;}&#10;&#10;/* Custom scrollbar for indicators if needed */&#10;.custom-scrollbar::-webkit-scrollbar {&#10;  height: 4px;&#10;}&#10;&#10;.custom-scrollbar::-webkit-scrollbar-track {&#10;  background: rgba(255, 255, 255, 0.1);&#10;  border-radius: 2px;&#10;}&#10;&#10;.custom-scrollbar::-webkit-scrollbar-thumb {&#10;  background: rgba(255, 255, 255, 0.3);&#10;  border-radius: 2px;&#10;}&#10;&#10;.custom-scrollbar::-webkit-scrollbar-thumb:hover {&#10;  background: rgba(255, 255, 255, 0.5);&#10;}&#10;&#10;:root {&#10;    --radius: 0.625rem;&#10;    --background: 0 0% 100%;&#10;    --foreground: 222.2 84% 4.9%;&#10;&#10;    --card: 0 0% 100%;&#10;    --card-foreground: 222.2 84% 4.9%;&#10;&#10;    --popover: 0 0% 100%;&#10;    --popover-foreground: 222.2 84% 4.9%;&#10;&#10;    --primary: 222.2 47.4% 11.2%;&#10;    --primary-foreground: 210 40% 98%;&#10;&#10;    --secondary: 210 40% 96.1%;&#10;    --secondary-foreground: 222.2 47.4% 11.2%;&#10;&#10;    --muted: 210 40% 96.1%;&#10;    --muted-foreground: 215.4 16.3% 46.9%;&#10;&#10;    --accent: 210 40% 96.1%;&#10;    --accent-foreground: 222.2 47.4% 11.2%;&#10;&#10;    --destructive: 0 84.2% 60.2%;&#10;    --destructive-foreground: 210 40% 98%;&#10;&#10;    --border: 214.3 31.8% 91.4%;&#10;    --input: 214.3 31.8% 91.4%;&#10;    --ring: 222.2 84% 4.9%;&#10;&#10;    /* Gallery-specific design tokens */&#10;    --gallery-bg: 0 0% 5%;&#10;    --gallery-text: 0 0% 95%;&#10;    --gallery-muted: 0 0% 60%;&#10;    --glass-bg: 0 0% 100% / 0.1;&#10;    --glass-border: 0 0% 100% / 0.2;&#10;    --button-glass: 0 0% 100% / 0.15;&#10;    --button-glass-hover: 0 0% 100% / 0.25;&#10;&#10;    /* Shadows */&#10;    --shadow-soft: 0 4px 24px -4px hsl(0 0% 0% / 0.1);&#10;    --shadow-glass: 0 8px 32px -8px hsl(0 0% 0% / 0.3);&#10;    --shadow-intense: 0 20px 50px -12px hsl(0 0% 0% / 0.4);&#10;&#10;    /* Transitions */&#10;    --transition-smooth: all 0.3s cubic-bezier(0.23, 1, 0.320, 1);&#10;    --transition-spring: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);&#10;&#10;    --sidebar-background: 0 0% 98%;&#10;    --sidebar-foreground: 240 5.3% 26.1%;&#10;    --sidebar-primary: 240 5.9% 10%;&#10;    --sidebar-primary-foreground: 0 0% 98%;&#10;    --sidebar-accent: 240 4.8% 95.9%;&#10;    --sidebar-accent-foreground: 240 5.9% 10%;&#10;    --sidebar-border: 220 13% 91%;&#10;    --sidebar-ring: 217.2 91.2% 59.8%;&#10;}&#10;&#10;.dark {&#10;    --background: 222.2 84% 4.9%;&#10;    --foreground: 210 40% 98%;&#10;    --card: 222.2 84% 4.9%;&#10;    --card-foreground: 210 40% 98%;&#10;    --popover: 222.2 84% 4.9%;&#10;    --popover-foreground: 210 40% 98%;&#10;    --primary: 210 40% 98%;&#10;    --primary-foreground: 222.2 47.4% 11.2%;&#10;    --secondary: 217.2 32.6% 17.5%;&#10;    --secondary-foreground: 210 40% 98%;&#10;    --muted: 217.2 32.6% 17.5%;&#10;    --muted-foreground: 215 20.2% 65.1%;&#10;    --accent: 217.2 32.6% 17.5%;&#10;    --accent-foreground: 210 40% 98%;&#10;    --destructive: 0 62.8% 30.6%;&#10;    --destructive-foreground: 210 40% 98%;&#10;    --border: 217.2 32.6% 17.5%;&#10;    --input: 217.2 32.6% 17.5%;&#10;    --ring: 212.7 26.8% 83.9%;&#10;    --sidebar-background: 240 5.9% 10%;&#10;    --sidebar-foreground: 240 4.8% 95.9%;&#10;    --sidebar-primary: 224.3 76.3% 48%;&#10;    --sidebar-primary-foreground: 0 0% 100%;&#10;    --sidebar-accent: 240 3.7% 15.9%;&#10;    --sidebar-accent-foreground: 240 4.8% 95.9%;&#10;    --sidebar-border: 240 3.7% 15.9%;&#10;    --sidebar-ring: 217.2 91.2% 59.8%;&#10;}&#10;&#10;@layer base {&#10;    * {&#10;        @apply border-border outline-ring/50;&#10;    }&#10;&#10;    body {&#10;        @apply bg-background text-foreground;&#10;    }&#10;}&#10;&#10;/* Performance optimizations */&#10;@layer utilities {&#10;    .transform-gpu {&#10;        transform: translate3d(0, 0, 0);&#10;    }&#10;&#10;    .will-change-transform {&#10;        will-change: transform;&#10;    }&#10;&#10;    .will-change-opacity {&#10;        will-change: opacity;&#10;    }&#10;&#10;    .contain-layout {&#10;        contain: layout;&#10;    }&#10;&#10;    .contain-paint {&#10;        contain: paint;&#10;    }&#10;&#10;    .contain-style {&#10;        contain: style;&#10;    }&#10;&#10;    .contain-strict {&#10;        contain: strict;&#10;    }&#10;}&#10;&#10;/* Optimize animations for better performance */&#10;@layer components {&#10;    .animate-fade-in {&#10;        animation: fade-in 0.4s cubic-bezier(0.23, 1, 0.320, 1);&#10;    }&#10;&#10;    .animate-scale-in {&#10;        animation: scale-in 0.2s cubic-bezier(0.23, 1, 0.320, 1);&#10;    }&#10;&#10;    .animate-slide-in-right {&#10;        animation: slide-in-right 0.3s cubic-bezier(0.23, 1, 0.320, 1);&#10;    }&#10;}&#10;&#10;/* Touch device optimizations */&#10;@media (hover: none) and (pointer: coarse) {&#10;    .hover\:scale-105:hover {&#10;        transform: none;&#10;    }&#10;&#10;    .hover\:scale-\[1\.02\]:hover {&#10;        transform: none;&#10;    }&#10;&#10;    .group:hover .group-hover\:scale-105 {&#10;        transform: none;&#10;    }&#10;&#10;    .group:hover .group-hover\:scale-110 {&#10;        transform: none;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/gallery/ImageCarousel.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/gallery/ImageCarousel.tsx" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import { useState, useRef, useEffect, useCallback } from &quot;react&quot;;&#10;import { CarouselImage } from &quot;./carousel/CarouselImage&quot;;&#10;import { CarouselNavigation } from &quot;./carousel/CarouselNavigation&quot;;&#10;import { CarouselTopBar } from &quot;./carousel/CarouselTopBar&quot;;&#10;import { ImageIndicators } from &quot;./carousel/ImageIndicators&quot;;&#10;import { ImageInfo } from &quot;./carousel/ImageInfo&quot;;&#10;import { galleryImages } from &quot;@/data/galleryData&quot;;&#10;import { useCarouselKeyboard } from &quot;./carousel/useCarouselKeyboard&quot;;&#10;&#10;interface ImageCarouselProps {&#10;  initialIndex?: number;&#10;  currentIndex?: number;&#10;  onIndexChange?: (index: number) =&gt; void;&#10;  onClose?: () =&gt; void;&#10;}&#10;&#10;export function ImageCarousel({&#10;  initialIndex = 0,&#10;  currentIndex: externalCurrentIndex,&#10;  onIndexChange,&#10;  onClose,&#10;}: ImageCarouselProps) {&#10;  const [currentIndex, setCurrentIndex] = useState(&#10;    externalCurrentIndex ?? initialIndex,&#10;  );&#10;  const [bgColor, setBgColor] = useState&lt;string | null&gt;(null);&#10;  const [isTransitioning, setIsTransitioning] = useState(false);&#10;  const carouselRef = useRef&lt;HTMLDivElement&gt;(null);&#10;  const scrollTimeoutRef = useRef&lt;NodeJS.Timeout | null&gt;(null);&#10;  const currentImageRef = useRef&lt;HTMLImageElement&gt;(null);&#10;&#10;  useEffect(() =&gt; {&#10;    const currentImage = galleryImages[currentIndex];&#10;    if (!currentImage) {&#10;      return;&#10;    }&#10;&#10;    setBgColor(currentImage.bgColor);&#10;  }, [currentIndex]);&#10;&#10;  // Sync external currentIndex with internal state&#10;  useEffect(() =&gt; {&#10;    if (&#10;      externalCurrentIndex !== undefined &amp;&amp;&#10;      externalCurrentIndex !== currentIndex&#10;    ) {&#10;      setCurrentIndex(externalCurrentIndex);&#10;      scrollToImage(externalCurrentIndex);&#10;    }&#10;  }, [externalCurrentIndex, currentIndex]);&#10;&#10;  // Handle keyboard navigation&#10;  useCarouselKeyboard({&#10;    onNext: () =&gt; goToNext(),&#10;    onPrevious: () =&gt; goToPrevious(),&#10;    onClose: onClose,&#10;  });&#10;&#10;  const updateCurrentIndex = useCallback(&#10;    (newIndex: number) =&gt; {&#10;      setCurrentIndex(newIndex);&#10;      onIndexChange?.(newIndex);&#10;    },&#10;    [onIndexChange],&#10;  );&#10;&#10;  const goToNext = () =&gt; {&#10;    if (currentIndex &lt; galleryImages.length - 1) {&#10;      const newIndex = currentIndex + 1;&#10;      goToImage(newIndex);&#10;    }&#10;  };&#10;&#10;  const goToPrevious = () =&gt; {&#10;    if (currentIndex &gt; 0) {&#10;      const newIndex = currentIndex - 1;&#10;      goToImage(newIndex);&#10;    }&#10;  };&#10;&#10;  const goToImage = (index: number) =&gt; {&#10;    // Prevent multiple rapid clicks during transition&#10;    if (isTransitioning || index === currentIndex) return;&#10;&#10;    setIsTransitioning(true);&#10;    scrollToImage(index);&#10;&#10;    // Clear any existing timeout&#10;    if (scrollTimeoutRef.current) {&#10;      clearTimeout(scrollTimeoutRef.current);&#10;    }&#10;&#10;    // Monitor scroll completion and update state when animation finishes&#10;    const checkScrollCompletion = () =&gt; {&#10;      if (carouselRef.current) {&#10;        const scrollLeft = carouselRef.current.scrollLeft;&#10;        const imageWidth = carouselRef.current.clientWidth;&#10;        const targetScrollPosition = index * imageWidth;&#10;&#10;        // Check if we're close enough to the target position (within 5px)&#10;        if (Math.abs(scrollLeft - targetScrollPosition) &lt; 5) {&#10;          updateCurrentIndex(index);&#10;          setIsTransitioning(false);&#10;        } else {&#10;          // Continue checking&#10;          scrollTimeoutRef.current = setTimeout(checkScrollCompletion, 50);&#10;        }&#10;      }&#10;    };&#10;&#10;    // Start checking after a short delay to let the smooth scroll begin&#10;    scrollTimeoutRef.current = setTimeout(checkScrollCompletion, 100);&#10;  };&#10;&#10;  const scrollToImage = (index: number) =&gt; {&#10;    if (carouselRef.current) {&#10;      const imageElement = carouselRef.current.children[index] as HTMLElement;&#10;      if (imageElement) {&#10;        imageElement.scrollIntoView({&#10;          behavior: &quot;smooth&quot;,&#10;          block: &quot;nearest&quot;,&#10;          inline: &quot;center&quot;,&#10;        });&#10;      }&#10;    }&#10;  };&#10;&#10;  // Handle scroll snap detection to update current index&#10;  useEffect(() =&gt; {&#10;    const carousel = carouselRef.current;&#10;    if (!carousel) return;&#10;&#10;    const handleScroll = () =&gt; {&#10;      // Don't update during manual transitions to avoid conflicts&#10;      if (isTransitioning) return;&#10;&#10;      const scrollLeft = carousel.scrollLeft;&#10;      const imageWidth = carousel.clientWidth;&#10;      const newIndex = Math.round(scrollLeft / imageWidth);&#10;&#10;      if (&#10;        newIndex !== currentIndex &amp;&amp;&#10;        newIndex &gt;= 0 &amp;&amp;&#10;        newIndex &lt; galleryImages.length&#10;      ) {&#10;        updateCurrentIndex(newIndex);&#10;      }&#10;    };&#10;&#10;    carousel.addEventListener(&quot;scroll&quot;, handleScroll, { passive: true });&#10;    return () =&gt; carousel.removeEventListener(&quot;scroll&quot;, handleScroll);&#10;  }, [currentIndex, isTransitioning, updateCurrentIndex]);&#10;&#10;  // Cleanup timeout on unmount&#10;  useEffect(() =&gt; {&#10;    return () =&gt; {&#10;      if (scrollTimeoutRef.current) {&#10;        clearTimeout(scrollTimeoutRef.current);&#10;      }&#10;    };&#10;  }, []);&#10;&#10;  // Initialize scroll position&#10;  useEffect(() =&gt; {&#10;    if (carouselRef.current &amp;&amp; initialIndex &gt; 0) {&#10;      scrollToImage(initialIndex);&#10;    }&#10;  }, [initialIndex]);&#10;&#10;  return (&#10;    &lt;div&#10;      className=&quot;fixed inset-0 backdrop-blur-sm z-50 flex flex-col transition-colors duration-700&quot;&#10;      style={{&#10;        backgroundColor: bgColor || &quot;transparent&quot;,&#10;      }}&#10;    &gt;&#10;      &lt;CarouselTopBar onClose={onClose} /&gt;&#10;&#10;      &lt;h1&#10;        className=&quot;text-3xl text-center font-bold text-white&quot;&#10;        style={{ letterSpacing: &quot;-0.05em&quot; }}&#10;      &gt;&#10;        the beauty of earth.&#10;      &lt;/h1&gt;&#10;&#10;      &lt;div className=&quot;flex-1 relative overflow-hidden&quot;&gt;&#10;        {/* Main carousel container with scroll snap */}&#10;        &lt;div&#10;          ref={carouselRef}&#10;          className=&quot;flex h-full overflow-x-auto snap-x snap-mandatory scrollbar-hide&quot;&#10;          style={{&#10;            scrollbarWidth: &quot;none&quot;,&#10;            msOverflowStyle: &quot;none&quot;,&#10;          }}&#10;        &gt;&#10;          {galleryImages.map((image, index) =&gt; (&#10;            &lt;div&#10;              key={image.id}&#10;              className=&quot;flex-shrink-0 w-full h-full flex items-center justify-center snap-center px-6&quot;&#10;            &gt;&#10;              &lt;CarouselImage&#10;                ref={index === currentIndex ? currentImageRef : null}&#10;                src={image.src}&#10;                alt={image.title}&#10;                priority={Math.abs(index - currentIndex) &lt;= 1}&#10;                blurDataURL={image.blurDataURL}&#10;              /&gt;&#10;            &lt;/div&gt;&#10;          ))}&#10;        &lt;/div&gt;&#10;&#10;        {/* Navigation arrows */}&#10;        &lt;CarouselNavigation&#10;          onNext={goToNext}&#10;          onPrevious={goToPrevious}&#10;          canGoNext={currentIndex &lt; galleryImages.length - 1}&#10;          canGoPrevious={currentIndex &gt; 0}&#10;        /&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className=&quot;flex-shrink-0 px-6 pb-10 space-y-4&quot;&gt;&#10;        &lt;ImageInfo image={galleryImages[currentIndex]} /&gt;&#10;        &lt;ImageIndicators&#10;          images={galleryImages}&#10;          currentIndex={currentIndex}&#10;          onImageSelect={goToImage}&#10;        /&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import { useState, useRef, useEffect, useCallback } from &quot;react&quot;;&#10;import { CarouselImage } from &quot;./carousel/CarouselImage&quot;;&#10;import { CarouselNavigation } from &quot;./carousel/CarouselNavigation&quot;;&#10;import { CarouselTopBar } from &quot;./carousel/CarouselTopBar&quot;;&#10;import { ImageIndicators } from &quot;./carousel/ImageIndicators&quot;;&#10;import { ImageInfo } from &quot;./carousel/ImageInfo&quot;;&#10;import { galleryImages } from &quot;@/data/galleryData&quot;;&#10;import { useCarouselKeyboard } from &quot;./carousel/useCarouselKeyboard&quot;;&#10;&#10;interface ImageCarouselProps {&#10;  initialIndex?: number;&#10;  currentIndex?: number;&#10;  onIndexChange?: (index: number) =&gt; void;&#10;  onClose?: () =&gt; void;&#10;}&#10;&#10;export function ImageCarousel({&#10;  initialIndex = 0,&#10;  currentIndex: externalCurrentIndex,&#10;  onIndexChange,&#10;  onClose,&#10;}: ImageCarouselProps) {&#10;  const [currentIndex, setCurrentIndex] = useState(&#10;    externalCurrentIndex ?? initialIndex,&#10;  );&#10;  const [bgColor, setBgColor] = useState&lt;string | null&gt;(null);&#10;  const [isTransitioning, setIsTransitioning] = useState(false);&#10;  const carouselRef = useRef&lt;HTMLDivElement&gt;(null);&#10;  const scrollTimeoutRef = useRef&lt;NodeJS.Timeout | null&gt;(null);&#10;  const currentImageRef = useRef&lt;HTMLImageElement&gt;(null);&#10;  const throttleRef = useRef&lt;NodeJS.Timeout | null&gt;(null);&#10;&#10;  // Buffer size: how many images to render on each side of current image&#10;  const BUFFER_SIZE = 1;&#10;&#10;  // Calculate which images should be rendered&#10;  const getVisibleIndices = useCallback(() =&gt; {&#10;    const start = Math.max(0, currentIndex - BUFFER_SIZE);&#10;    const end = Math.min(galleryImages.length - 1, currentIndex + BUFFER_SIZE);&#10;    return { start, end };&#10;  }, [currentIndex]);&#10;&#10;  useEffect(() =&gt; {&#10;    const currentImage = galleryImages[currentIndex];&#10;    if (!currentImage) {&#10;      return;&#10;    }&#10;&#10;    setBgColor(currentImage.bgColor);&#10;  }, [currentIndex]);&#10;&#10;  // Sync external currentIndex with internal state&#10;  useEffect(() =&gt; {&#10;    if (&#10;      externalCurrentIndex !== undefined &amp;&amp;&#10;      externalCurrentIndex !== currentIndex&#10;    ) {&#10;      setCurrentIndex(externalCurrentIndex);&#10;      scrollToImage(externalCurrentIndex);&#10;    }&#10;  }, [externalCurrentIndex, currentIndex]);&#10;&#10;  // Handle keyboard navigation&#10;  useCarouselKeyboard({&#10;    onNext: () =&gt; goToNext(),&#10;    onPrevious: () =&gt; goToPrevious(),&#10;    onClose: onClose,&#10;  });&#10;&#10;  const updateCurrentIndex = useCallback(&#10;    (newIndex: number) =&gt; {&#10;      setCurrentIndex(newIndex);&#10;      onIndexChange?.(newIndex);&#10;    },&#10;    [onIndexChange],&#10;  );&#10;&#10;  const goToNext = () =&gt; {&#10;    if (currentIndex &lt; galleryImages.length - 1) {&#10;      const newIndex = currentIndex + 1;&#10;      goToImage(newIndex);&#10;    }&#10;  };&#10;&#10;  const goToPrevious = () =&gt; {&#10;    if (currentIndex &gt; 0) {&#10;      const newIndex = currentIndex - 1;&#10;      goToImage(newIndex);&#10;    }&#10;  };&#10;&#10;  const goToImage = (index: number) =&gt; {&#10;    // Prevent multiple rapid clicks during transition&#10;    if (isTransitioning || index === currentIndex) return;&#10;&#10;    setIsTransitioning(true);&#10;    scrollToImage(index);&#10;&#10;    // Clear any existing timeout&#10;    if (scrollTimeoutRef.current) {&#10;      clearTimeout(scrollTimeoutRef.current);&#10;    }&#10;&#10;    // Monitor scroll completion and update state when animation finishes&#10;    const checkScrollCompletion = () =&gt; {&#10;      if (carouselRef.current) {&#10;        const scrollLeft = carouselRef.current.scrollLeft;&#10;        const imageWidth = carouselRef.current.clientWidth;&#10;        const targetScrollPosition = index * imageWidth;&#10;&#10;        // Check if we're close enough to the target position (within 5px)&#10;        if (Math.abs(scrollLeft - targetScrollPosition) &lt; 5) {&#10;          updateCurrentIndex(index);&#10;          setIsTransitioning(false);&#10;        } else {&#10;          // Continue checking&#10;          scrollTimeoutRef.current = setTimeout(checkScrollCompletion, 50);&#10;        }&#10;      }&#10;    };&#10;&#10;    // Start checking after a short delay to let the smooth scroll begin&#10;    scrollTimeoutRef.current = setTimeout(checkScrollCompletion, 100);&#10;  };&#10;&#10;  const scrollToImage = (index: number) =&gt; {&#10;    if (carouselRef.current) {&#10;      const imageElement = carouselRef.current.children[index] as HTMLElement;&#10;      if (imageElement) {&#10;        imageElement.scrollIntoView({&#10;          behavior: &quot;smooth&quot;,&#10;          block: &quot;nearest&quot;,&#10;          inline: &quot;center&quot;,&#10;        });&#10;      }&#10;    }&#10;  };&#10;&#10;  // Create throttled scroll handler using useRef for better performance&#10;  const handleScroll = useCallback(() =&gt; {&#10;    const carousel = carouselRef.current;&#10;    if (!carousel || isTransitioning) return;&#10;&#10;    const scrollLeft = carousel.scrollLeft;&#10;    const imageWidth = carousel.clientWidth;&#10;    const newIndex = Math.round(scrollLeft / imageWidth);&#10;&#10;    if (&#10;      newIndex !== currentIndex &amp;&amp;&#10;      newIndex &gt;= 0 &amp;&amp;&#10;      newIndex &lt; galleryImages.length&#10;    ) {&#10;      updateCurrentIndex(newIndex);&#10;    }&#10;  }, [currentIndex, isTransitioning, updateCurrentIndex]);&#10;&#10;  const throttledScrollHandler = useCallback(() =&gt; {&#10;    if (throttleRef.current) return;&#10;&#10;    throttleRef.current = setTimeout(() =&gt; {&#10;      handleScroll();&#10;      throttleRef.current = null;&#10;    }, 16); // ~60fps throttling&#10;  }, [handleScroll]);&#10;&#10;  // Handle scroll snap detection to update current index&#10;  useEffect(() =&gt; {&#10;    const carousel = carouselRef.current;&#10;    if (!carousel) return;&#10;&#10;    carousel.addEventListener(&quot;scroll&quot;, throttledScrollHandler, { passive: true });&#10;    return () =&gt; carousel.removeEventListener(&quot;scroll&quot;, throttledScrollHandler);&#10;  }, [throttledScrollHandler]);&#10;&#10;  // Cleanup timeouts on unmount&#10;  useEffect(() =&gt; {&#10;    return () =&gt; {&#10;      if (scrollTimeoutRef.current) {&#10;        clearTimeout(scrollTimeoutRef.current);&#10;      }&#10;      if (throttleRef.current) {&#10;        clearTimeout(throttleRef.current);&#10;      }&#10;    };&#10;  }, []);&#10;&#10;  // Initialize scroll position&#10;  useEffect(() =&gt; {&#10;    if (carouselRef.current &amp;&amp; initialIndex &gt; 0) {&#10;      scrollToImage(initialIndex);&#10;    }&#10;  }, [initialIndex]);&#10;&#10;  const { start, end } = getVisibleIndices();&#10;&#10;  return (&#10;    &lt;div&#10;      className=&quot;fixed inset-0 backdrop-blur-sm z-50 flex flex-col transition-colors duration-700&quot;&#10;      style={{&#10;        backgroundColor: bgColor || &quot;transparent&quot;,&#10;      }}&#10;    &gt;&#10;      &lt;CarouselTopBar onClose={onClose} /&gt;&#10;&#10;      &lt;h1&#10;        className=&quot;text-3xl text-center font-bold text-white&quot;&#10;        style={{ letterSpacing: &quot;-0.05em&quot; }}&#10;      &gt;&#10;        the beauty of earth.&#10;      &lt;/h1&gt;&#10;&#10;      &lt;div className=&quot;flex-1 relative overflow-hidden&quot;&gt;&#10;        {/* Main carousel container with scroll snap */}&#10;        &lt;div&#10;          ref={carouselRef}&#10;          className=&quot;flex h-full overflow-x-auto snap-x snap-mandatory scrollbar-hide&quot;&#10;          style={{&#10;            scrollbarWidth: &quot;none&quot;,&#10;            msOverflowStyle: &quot;none&quot;,&#10;          }}&#10;        &gt;&#10;          {galleryImages.map((image, index) =&gt; {&#10;            // Only render images within the visible range&#10;            const shouldRender = index &gt;= start &amp;&amp; index &lt;= end;&#10;&#10;            return (&#10;              &lt;div&#10;                key={image.id}&#10;                className=&quot;flex-shrink-0 w-full h-full flex items-center justify-center snap-center px-6&quot;&#10;              &gt;&#10;                {shouldRender ? (&#10;                  &lt;CarouselImage&#10;                    ref={index === currentIndex ? currentImageRef : null}&#10;                    src={image.src}&#10;                    alt={image.title}&#10;                    priority={index === currentIndex}&#10;                    blurDataURL={image.blurDataURL}&#10;                  /&gt;&#10;                ) : (&#10;                  // Placeholder div to maintain scroll positions&#10;                  &lt;div className=&quot;w-full h-full&quot; /&gt;&#10;                )}&#10;              &lt;/div&gt;&#10;            );&#10;          })}&#10;        &lt;/div&gt;&#10;&#10;        {/* Navigation arrows */}&#10;        &lt;CarouselNavigation&#10;          onNext={goToNext}&#10;          onPrevious={goToPrevious}&#10;          canGoNext={currentIndex &lt; galleryImages.length - 1}&#10;          canGoPrevious={currentIndex &gt; 0}&#10;        /&gt;&#10;      &lt;/div&gt;&#10;&#10;      &lt;div className=&quot;flex-shrink-0 px-6 pb-10 space-y-4&quot;&gt;&#10;        &lt;ImageInfo image={galleryImages[currentIndex]} /&gt;&#10;        &lt;ImageIndicators&#10;          images={galleryImages}&#10;          currentIndex={currentIndex}&#10;          onImageSelect={goToImage}&#10;        /&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/gallery/carousel/CarouselNavigation.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/gallery/carousel/CarouselNavigation.tsx" />
              <option name="updatedContent" value="import { ChevronLeft, ChevronRight } from &quot;lucide-react&quot;;&#10;&#10;interface CarouselNavigationProps {&#10;  onNext: () =&gt; void;&#10;  onPrevious: () =&gt; void;&#10;  canGoNext: boolean;&#10;  canGoPrevious: boolean;&#10;}&#10;&#10;export function CarouselNavigation({&#10;  onNext,&#10;  onPrevious,&#10;  canGoNext,&#10;  canGoPrevious,&#10;}: CarouselNavigationProps) {&#10;  return (&#10;    &lt;&gt;&#10;      {/* Previous button */}&#10;      &lt;button&#10;        onClick={onPrevious}&#10;        disabled={!canGoPrevious}&#10;        className={`absolute left-6 top-1/2 -translate-y-1/2 z-10 p-4 rounded-full bg-black/30 backdrop-blur-xl border border-white/15 transition-all duration-300 ease-out shadow-lg ${&#10;          canGoPrevious&#10;            ? &quot;hover:bg-black/50 hover:scale-105 hover:shadow-xl active:scale-95 opacity-100&quot;&#10;            : &quot;opacity-40 cursor-not-allowed&quot;&#10;        }`}&#10;        aria-label=&quot;Previous image&quot;&#10;      &gt;&#10;        &lt;ChevronLeft className=&quot;w-6 h-6 text-white&quot; strokeWidth={2.5} /&gt;&#10;      &lt;/button&gt;&#10;&#10;      {/* Next button */}&#10;      &lt;button&#10;        onClick={onNext}&#10;        disabled={!canGoNext}&#10;        className={`absolute right-6 top-1/2 -translate-y-1/2 z-10 p-4 rounded-full bg-black/30 backdrop-blur-xl border border-white/15 transition-all duration-300 ease-out shadow-lg ${&#10;          canGoNext&#10;            ? &quot;hover:bg-black/50 hover:scale-105 hover:shadow-xl active:scale-95 opacity-100&quot;&#10;            : &quot;opacity-40 cursor-not-allowed&quot;&#10;        }`}&#10;        aria-label=&quot;Next image&quot;&#10;      &gt;&#10;        &lt;ChevronRight className=&quot;w-6 h-6 text-white&quot; strokeWidth={2.5} /&gt;&#10;      &lt;/button&gt;&#10;    &lt;/&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/components/gallery/carousel/ImageIndicators.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/gallery/carousel/ImageIndicators.tsx" />
              <option name="originalContent" value="import Image from &quot;next/image&quot;;&#10;import { useEffect, useRef } from &quot;react&quot;;&#10;import { type GalleryImage } from &quot;@/data/galleryData&quot;;&#10;&#10;interface ImageIndicatorsProps {&#10;  images: GalleryImage[];&#10;  currentIndex: number;&#10;  onImageSelect: (index: number) =&gt; void;&#10;}&#10;&#10;export function ImageIndicators({&#10;  images,&#10;  currentIndex,&#10;  onImageSelect,&#10;}: ImageIndicatorsProps) {&#10;  const containerRef = useRef&lt;HTMLDivElement&gt;(null);&#10;  const activeButtonRef = useRef&lt;HTMLButtonElement&gt;(null);&#10;&#10;  // Scroll to active thumbnail when currentIndex changes&#10;  useEffect(() =&gt; {&#10;    if (containerRef.current &amp;&amp; activeButtonRef.current) {&#10;      const container = containerRef.current;&#10;      const activeButton = activeButtonRef.current;&#10;&#10;      const containerRect = container.getBoundingClientRect();&#10;      const buttonRect = activeButton.getBoundingClientRect();&#10;&#10;      // Calculate if button is outside visible area&#10;      const isButtonVisible =&#10;        buttonRect.left &gt;= containerRect.left &amp;&amp;&#10;        buttonRect.right &lt;= containerRect.right;&#10;&#10;      if (!isButtonVisible) {&#10;        // Calculate scroll position to center the active button&#10;        const buttonCenter =&#10;          activeButton.offsetLeft + activeButton.offsetWidth / 2;&#10;        const containerCenter = container.offsetWidth / 2;&#10;        const scrollPosition = buttonCenter - containerCenter;&#10;&#10;        container.scrollTo({&#10;          left: scrollPosition,&#10;          behavior: &quot;smooth&quot;,&#10;        });&#10;      }&#10;    }&#10;  }, [currentIndex]);&#10;&#10;  return (&#10;    &lt;div className=&quot;flex justify-center pb-4&quot;&gt;&#10;      &lt;div&#10;        ref={containerRef}&#10;        className=&quot;flex items-center gap-3 p-3 h-[90px] bg-black/20 backdrop-blur-xl rounded-2xl border border-white/10 max-w-full overflow-x-auto scrollbar-hide shadow-lg&quot;&#10;        style={{&#10;          WebkitBackdropFilter: &quot;blur(24px)&quot;,&#10;          backdropFilter: &quot;blur(24px)&quot;,&#10;          willChange: &quot;backdrop-filter&quot;,&#10;          isolation: &quot;isolate&quot;,&#10;        }}&#10;      &gt;&#10;        {images.map((image, index) =&gt; (&#10;          &lt;button&#10;            key={image.id}&#10;            ref={index === currentIndex ? activeButtonRef : null}&#10;            onClick={() =&gt; onImageSelect(index)}&#10;            className={`relative flex-shrink-0 rounded-xl overflow-hidden transition-all duration-300 ease-out ${&#10;              index === currentIndex&#10;                ? &quot;w-16 h-16 ring-2 ring-white/50 shadow-lg scale-110&quot;&#10;                : &quot;w-12 h-12 ring-1 ring-white/20 hover:ring-white/40 hover:scale-105 active:scale-95&quot;&#10;            }`}&#10;            aria-label={`Go to image ${index + 1}: ${image.title}`}&#10;          &gt;&#10;            &lt;Image&#10;              src={image.src}&#10;              alt={image.title}&#10;              fill&#10;              loading=&quot;lazy&quot;&#10;              sizes=&quot;64px&quot;&#10;              className=&quot;object-cover&quot;&#10;              placeholder={image.blurDataURL ? &quot;blur&quot; : &quot;empty&quot;}&#10;              blurDataURL={image.blurDataURL}&#10;            /&gt;&#10;            {/* Current image overlay */}&#10;            {index === currentIndex &amp;&amp; (&#10;              &lt;div className=&quot;absolute inset-0 bg-gradient-to-t from-black/30 via-transparent to-transparent&quot; /&gt;&#10;            )}&#10;            {/* Active indicator dot */}&#10;            {index === currentIndex &amp;&amp; (&#10;              &lt;div className=&quot;absolute bottom-1 left-1/2 transform -translate-x-1/2 w-1.5 h-1.5 bg-white/80 rounded-full shadow-sm&quot; /&gt;&#10;            )}&#10;          &lt;/button&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="import Image from &quot;next/image&quot;;&#10;import { useEffect, useRef } from &quot;react&quot;;&#10;import { type GalleryImage } from &quot;@/data/galleryData&quot;;&#10;&#10;interface ImageIndicatorsProps {&#10;  images: GalleryImage[];&#10;  currentIndex: number;&#10;  onImageSelect: (index: number) =&gt; void;&#10;}&#10;&#10;export function ImageIndicators({&#10;  images,&#10;  currentIndex,&#10;  onImageSelect,&#10;}: ImageIndicatorsProps) {&#10;  const containerRef = useRef&lt;HTMLDivElement&gt;(null);&#10;  const activeButtonRef = useRef&lt;HTMLButtonElement&gt;(null);&#10;&#10;  // Scroll to active thumbnail when currentIndex changes&#10;  useEffect(() =&gt; {&#10;    if (containerRef.current &amp;&amp; activeButtonRef.current) {&#10;      const container = containerRef.current;&#10;      const activeButton = activeButtonRef.current;&#10;&#10;      const containerRect = container.getBoundingClientRect();&#10;      const buttonRect = activeButton.getBoundingClientRect();&#10;&#10;      // Calculate if button is outside visible area&#10;      const isButtonVisible =&#10;        buttonRect.left &gt;= containerRect.left &amp;&amp;&#10;        buttonRect.right &lt;= containerRect.right;&#10;&#10;      if (!isButtonVisible) {&#10;        // Calculate scroll position to center the active button&#10;        const buttonCenter =&#10;          activeButton.offsetLeft + activeButton.offsetWidth / 2;&#10;        const containerCenter = container.offsetWidth / 2;&#10;        const scrollPosition = buttonCenter - containerCenter;&#10;&#10;        container.scrollTo({&#10;          left: scrollPosition,&#10;          behavior: &quot;smooth&quot;,&#10;        });&#10;      }&#10;    }&#10;  }, [currentIndex]);&#10;&#10;  return (&#10;    &lt;div className=&quot;flex justify-center pb-4&quot;&gt;&#10;      &lt;div&#10;        ref={containerRef}&#10;        className=&quot;flex items-center gap-3 p-3 h-[90px] bg-black/20 backdrop-blur-xl rounded-2xl border border-white/10 max-w-full overflow-x-auto scrollbar-hide shadow-lg&quot;&#10;        style={{&#10;          WebkitBackdropFilter: &quot;blur(24px)&quot;,&#10;          backdropFilter: &quot;blur(24px)&quot;,&#10;          willChange: &quot;backdrop-filter&quot;,&#10;          isolation: &quot;isolate&quot;,&#10;        }}&#10;      &gt;&#10;        {images.map((image, index) =&gt; (&#10;          &lt;button&#10;            key={image.id}&#10;            ref={index === currentIndex ? activeButtonRef : null}&#10;            onClick={() =&gt; onImageSelect(index)}&#10;            className={`relative flex-shrink-0 rounded-xl overflow-hidden transition-all duration-300 ease-out ${&#10;              index === currentIndex&#10;                ? &quot;w-16 h-16 ring-2 ring-white/50 shadow-lg scale-110&quot;&#10;                : &quot;w-12 h-12 ring-1 ring-white/20 hover:ring-white/40 hover:scale-105 active:scale-95&quot;&#10;            }`}&#10;            aria-label={`Go to image ${index + 1}: ${image.title}`}&#10;          &gt;&#10;            &lt;Image&#10;              src={image.src}&#10;              alt={image.title}&#10;              fill&#10;              loading=&quot;lazy&quot;&#10;              sizes=&quot;64px&quot;&#10;              className=&quot;object-cover&quot;&#10;              placeholder={image.blurDataURL ? &quot;blur&quot; : &quot;empty&quot;}&#10;              blurDataURL={image.blurDataURL}&#10;            /&gt;&#10;            {/* Current image overlay */}&#10;            {index === currentIndex &amp;&amp; (&#10;              &lt;div className=&quot;absolute inset-0 bg-gradient-to-t from-black/30 via-transparent to-transparent&quot; /&gt;&#10;            )}&#10;            {/* Active indicator dot */}&#10;            {index === currentIndex &amp;&amp; (&#10;              &lt;div className=&quot;absolute bottom-1 left-1/2 transform -translate-x-1/2 w-1.5 h-1.5 bg-white/80 rounded-full shadow-sm&quot; /&gt;&#10;            )}&#10;          &lt;/button&gt;&#10;        ))}&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>